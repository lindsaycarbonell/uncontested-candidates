{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "/home/gaganb/projects/geojson2svg/node_modules/deepmerge/index.js",
    "/home/gaganb/projects/geojson2svg/node_modules/multigeojson/index.js",
    "/home/gaganb/projects/geojson2svg/src/converter.js",
    "/home/gaganb/projects/geojson2svg/src/instance.js",
    "/home/gaganb/projects/geojson2svg/src/main.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define(factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.deepmerge = factory();\n    }\n}(this, function () {\n\nreturn function deepmerge(target, src) {\n    var array = Array.isArray(src);\n    var dst = array && [] || {};\n\n    if (array) {\n        target = target || [];\n        dst = dst.concat(target);\n        src.forEach(function(e, i) {\n            if (typeof dst[i] === 'undefined') {\n                dst[i] = e;\n            } else if (typeof e === 'object') {\n                dst[i] = deepmerge(target[i], e);\n            } else {\n                if (target.indexOf(e) === -1) {\n                    dst.push(e);\n                }\n            }\n        });\n    } else {\n        if (target && typeof target === 'object') {\n            Object.keys(target).forEach(function (key) {\n                dst[key] = target[key];\n            })\n        }\n        Object.keys(src).forEach(function (key) {\n            if (typeof src[key] !== 'object' || !src[key]) {\n                dst[key] = src[key];\n            }\n            else {\n                if (!target[key]) {\n                    dst[key] = src[key];\n                } else {\n                    dst[key] = deepmerge(target[key], src[key]);\n                }\n            }\n        });\n    }\n\n    return dst;\n}\n\n}));\n",
    "//index.js \n(function() { \n\tvar singles = ['Point', 'LineString', 'Polygon'];\n\tvar multies = ['MultiPoint', 'MultiLineString', 'MultiPolygon'];\n\tfunction explode(g) {\n\t  if( multies.indexOf(g.type) > -1) {\n\t    return g.coordinates.map(function(part) {\n\t      var single = {};\n\t      single.type = g.type.replace('Multi','');\n\t      single.coordinates = part;\n        if(g.crs) single.crs = g.crs;\n\t      return single;\n\t    });  \n\t  } else {\n\t    return false;\n\t  }\n\t}\n\tfunction implode(gs) {\n\t  var sameType = gs.every(function(g) { \n\t    return singles.indexOf(g.type) > -1;\n\t  })\n    var crs = gs[0].crs || 0;\n    var sameCrs = gs.every(function(g) {\n      var gcrs = g.crs || 0;\n      return gcrs == crs;\n    });\n\t  if(sameType && sameCrs) {\n\t    var multi = {};\n\t    multi.type = 'Multi' + gs[0].type;\n\t    multi.coordinates = [];\n      if(crs != 0) multi.crs = crs;\n\t    gs.forEach(function(g) {\n\t      multi.coordinates.push(g.coordinates);\n\t    });\n\t    return multi;\n\t  } else {\n\t    return false;\n\t  }\n\t};\n\tvar multigeojson = {\n\t  explode: explode,\n\t  implode: implode\n\t};\n\tif(typeof module !== 'undefined' && module.exports) {\n\t  module.exports = multigeojson;\n\t} else if(window) {\n\t  window.multigeojson = multigeojson;\n\t}\n})();\n",
    "//converter.js\nvar multi = require('multigeojson');\nfunction getCoordString(coords,res,origin) {\n  //origin - svg image origin \n  var coordStr = coords.map(function(coord) {\n    return (coord[0] - origin.x)/res + ',' + (origin.y - coord[1])/res;\n  });\n  return coordStr.join(' ');\n}\nfunction addAttributes(ele,attributes) {\n  var part = ele.split('/>')[0];\n  for(var key in attributes) {\n    if(attributes[key]) {\n      part += ' ' + key + '=\"' + attributes[key] + '\"';\n    }\n  }\n  return part + ' />';\n}\n\nfunction point(geom,res,origin,opt) {\n  var r = opt && opt.r ? opt.r : 1;\n  var path = 'M' + getCoordString([geom.coordinates],res,origin)\n    +' m'+ -r+ ',0'+ ' a'+r+','+ r + ' 0 1,1 '+ 2*r + ','+0\n    +' a'+r+','+ r + ' 0 1,1 '+ -2*r + ','+0;\n  return [path];\n}\nfunction multiPoint(geom,res,origin,opt) {\n  var explode = opt && opt.hasOwnProperty('explode') ? opt.explode : false;\n  var paths = multi.explode(geom).map(function(single) {\n    return point(single,res,origin,opt)[0];\n  });\n  if(!explode) return [paths.join(' ')];\n  return paths;\n\n}\nfunction lineString(geom,res,origin,otp) {\n  var coords = getCoordString(geom.coordinates,res,origin);\n  var path = 'M'+ coords;  \n  return [path];\n}\nfunction multiLineString(geom,res,origin,opt) {\n  var explode = opt && opt.hasOwnProperty('explode') ? opt.explode : false;\n  var paths = multi.explode(geom).map(function(single) {\n    return lineString(single,res,origin,opt)[0];\n  });\n  if(!explode) return [paths.join(' ')];\n  return paths;\n}\nfunction polygon(geom,res,origin,opt) {\n  var mainStr,holes,holeStr;\n  mainStr = getCoordString(geom.coordinates[0],res,origin);\n  if (geom.coordinates.length > 1) {\n    holes = geom.coordinates.slice(1,geom.coordinates.length);\n  }\n  var path = 'M'+ mainStr;\n  if(holes) {\n    for(var i=0;i<holes.length; i++) {\n      path += ' M' +  getCoordString(holes[i],res,origin);\n    }\n  }\n  path += 'Z';\n  return [path];\n}\nfunction multiPolygon(geom,res,origin,opt) {\n  var explode = opt.hasOwnProperty('explode') ? opt.explode : false;\n  var paths = multi.explode(geom).map(function(single) {\n    return polygon(single,res,origin,opt)[0];\n  });\n  if(!explode) return [paths.join(' ').replace(/Z/g,'') + 'Z'];\n  return paths;\n}\nmodule.exports = {\n  Point: point,\n  MultiPoint: multiPoint,\n  LineString: lineString,\n  MultiLineString: multiLineString,\n  Polygon: polygon,\n  MultiPolygon: multiPolygon\n};\n",
    "var merge = require('deepmerge'),\n\tconverter = require('./converter.js');\n\n//g2svg as geojson2svg (shorthand)\nvar g2svg = function(options) {\n  this.options = options || {};\n  this.viewportSize = this.options.viewportSize || \n    {width: 256, height: 256};\n  this.mapExtent = this.options.mapExtent ||\n    {\n      left: -20037508.342789244,\n      right: 20037508.342789244,\n      bottom: -20037508.342789244,\n      top: 20037508.342789244\n    };\n  this.res = this.calResolution(this.mapExtent,this.viewportSize,\n    this.options.fitTo);\n};\ng2svg.prototype.calResolution = function(extent,size,fitTo) {\n  var xres = (extent.right - extent.left)/size.width;\n  var yres = (extent.top - extent.bottom)/size.height;\n  if (fitTo) { \n    if (fitTo.toLowerCase() === 'width') {\n      return xres;\n    } else if (fitTo.toLowerCase() === 'height') {\n      return yres;\n    } else {\n      throw new Error('\"fitTo\" option should be \"width\" or \"height\" ');\n    }\n  } else {\n    return Math.max(xres,yres);\n  }\n};\ng2svg.prototype.convert = function(geojson,options)  {\n  var opt = merge(merge({},this.options), options || {});\n  var multiGeometries = ['MultiPoint','MultiLineString','MultiPolygon'];\n  var geometries = ['Point', 'LineString', 'Polygon'];\n  var svgElements = [];\n  if (geojson.type == 'FeatureCollection') {\n    for(var i=0; i< geojson.features.length; i++) {\n      svgElements = svgElements.concat(\n        this.convertFeature(geojson.features[i],opt));\n    }\n  } else if (geojson.type == 'Feature') {\n    svgElements = this.convertFeature(geojson,opt);\n  } else if (geojson.type == 'GeometryCollection') {\n    for(var i=0; i< geojson.geometries.length; i++) {\n      svgElements = svgElements.concat(\n        this.convertGeometry(geojson.geometries[i],opt));\n    }\n  } else if (converter[geojson.type]) {\n    svgElements = this.convertGeometry(geojson,opt);\n  } else {\n    return;\n  }\n  if(opt.callback) opt.callback.call(this,svgElements);\n  return svgElements;\n};\ng2svg.prototype.convertFeature = function(feature,options) {\n  if(!feature && !feature.geometry) return;\n  var opt = merge(merge({},this.options), options || {});\n  opt.attributes = opt.attributes || {};\n  opt.attributes.id = opt.attributes.id || feature.id || \n    (feature.properties && feature.properties.id ? feature.properties.id : null);\n  return this.convertGeometry(feature.geometry,opt);\n};\ng2svg.prototype.convertGeometry = function(geom,options) {\n  if(converter[geom.type]) {\n    var opt = merge(merge({},this.options), options || {});\n    var output = opt.output || 'svg';\n    var paths = converter[geom.type].call(this,geom,\n      this.res,\n      {x:this.mapExtent.left,y:this.mapExtent.top},\n      opt\n    );\n    var svgJsons,svgEles;\n    if (output.toLowerCase() == 'svg') {\n      svgJsons = paths.map(function(path) {\n        return pathToSvgJson(path,geom.type,opt.attributes,opt);\n      });\n      svgEles = svgJsons.map(function(json) {\n        return jsonToSvgElement(json,geom.type);\n      });\n      return svgEles;\n    } else {\n      return paths;\n    }\n  } else {\n    return;\n  }\n};\nvar pathToSvgJson = function(path,type,attributes,opt) {\n  var svg = {};\n  var forcePath = opt && opt.hasOwnProperty('forcePath') ? opt.forcePath\n     : true;\n  if((type == 'Point' || type == 'MultiPoint') && !forcePath) {\n    svg['cx'] = path.split(',')[0];\n    svg['cy'] = path.split(',')[1];\n    svg['r'] = opt && opt.r ? opt.r : '1';\n  } else {\n    svg = {d: path};\n    if(type == 'Polygon' || type == 'MultiPolygon') {\n      svg['fill-rule'] == 'evenodd'; \n    } \n  }\n  for (var key in attributes) {\n    svg[key]= attributes[key];\n  }\n  return svg;\n};\nvar jsonToSvgElement = function(json,type,opt) {\n  var forcePath = opt && opt.hasOwnProperty('forcePath') ? opt.forcePath\n     : true;\n  var ele ='<path';\n  if((type == 'Point' || type == 'MultiPoint') && !forcePath) {\n    ele = '<circle';\n  }\n  for(var key in json) {\n    ele += ' ' + key +'=\"' + json[key] + '\"';\n  }\n  ele += '/>';\n  return ele;\n};\n\nmodule.exports = g2svg;\n",
    "var g2svg = require('./instance.js');\nvar geojson2svg = function(options) {\n  return new g2svg(options);\n};\n\nmodule.exports = geojson2svg;\n"
  ]
}